{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"estherxyx.github.io/learn-python Intro This is blog about my python study footprint Hello World from estherxyx :","title":"Home"},{"location":"#estherxyxgithubiolearn-python","text":"","title":"estherxyx.github.io/learn-python"},{"location":"#intro","text":"This is blog about my python study footprint Hello World from estherxyx :","title":"Intro"},{"location":"backend/keywords/","text":"Cloud Services Storge In memory data File data csv Database Schema {age: int, name: str, ...} SQL, NoSQL Compute Access Control","title":"Cloud Services"},{"location":"backend/keywords/#cloud-services","text":"","title":"Cloud Services"},{"location":"backend/keywords/#storge","text":"In memory data File data csv Database Schema {age: int, name: str, ...} SQL, NoSQL","title":"Storge"},{"location":"backend/keywords/#compute","text":"","title":"Compute"},{"location":"backend/keywords/#access-control","text":"","title":"Access Control"},{"location":"leetcode/data-structure/","text":"WIP leetcode::study-plan::algorithms OOD - object-oriented-design # Instance -> Class # Instance -> method/function, attribute/property # Object -> JSON -> {\"name\": \"Andy\"} class Car: def __init__(self, brand): self.speed = 0 self.val = 2 self.brand = brand def run(self, speed): self.speed = speed class Truck(Car): def __init__(self, brand): super(brand) self.load = 200 car1 = Car(\"brand1\") # {\"speed\": 0, \"brand\": \"brand1\"} car2 = Car(\"brand2\") # {\"speed\": 0, \"brand\": \"brand2\"} print(car1.speed) # 0 car1.run(10) print(car1.speed) # 10 car1 = Truck(\"brand1\") class Person: def __init__(self, dna=\"\", child=None): self.dna = dna self.child = child p1 = Person(\"aaaa\") p2 = Person(\"bbbb\") p3 = Person(\"cccc\") p1.child = p2 p2.child = p3 def reverseList(self, person: Person) -> Person: people = [] # [\"aaaa\",] god = Person() god.child = person while person: #p3 people.append(person.dna) person = person.child p1 = god.child reverseList(p1) Big-O O(1) O(n) : number of elements -> n O(n^2) Python Keywords # enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango'] # setting up new array with length n ouside of loops nums = [0]*length # inside the loop no \"append\" or self needed # see eg in squares-of-a-sorted-array # sort() # returns the ordered array from min to max prime_numbers = [11, 3, 7, 5, 2] # sort the list prime_numbers.sort() print(prime_numbers) # >>> [2, 3, 5, 7, 11]","title":"Data structure"},{"location":"leetcode/data-structure/#wip","text":"leetcode::study-plan::algorithms","title":"WIP"},{"location":"leetcode/data-structure/#ood-object-oriented-design","text":"# Instance -> Class # Instance -> method/function, attribute/property # Object -> JSON -> {\"name\": \"Andy\"} class Car: def __init__(self, brand): self.speed = 0 self.val = 2 self.brand = brand def run(self, speed): self.speed = speed class Truck(Car): def __init__(self, brand): super(brand) self.load = 200 car1 = Car(\"brand1\") # {\"speed\": 0, \"brand\": \"brand1\"} car2 = Car(\"brand2\") # {\"speed\": 0, \"brand\": \"brand2\"} print(car1.speed) # 0 car1.run(10) print(car1.speed) # 10 car1 = Truck(\"brand1\") class Person: def __init__(self, dna=\"\", child=None): self.dna = dna self.child = child p1 = Person(\"aaaa\") p2 = Person(\"bbbb\") p3 = Person(\"cccc\") p1.child = p2 p2.child = p3 def reverseList(self, person: Person) -> Person: people = [] # [\"aaaa\",] god = Person() god.child = person while person: #p3 people.append(person.dna) person = person.child p1 = god.child reverseList(p1)","title":"OOD - object-oriented-design"},{"location":"leetcode/data-structure/#big-o","text":"O(1) O(n) : number of elements -> n O(n^2)","title":"Big-O"},{"location":"leetcode/data-structure/#python-keywords","text":"# enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango'] # setting up new array with length n ouside of loops nums = [0]*length # inside the loop no \"append\" or self needed # see eg in squares-of-a-sorted-array # sort() # returns the ordered array from min to max prime_numbers = [11, 3, 7, 5, 2] # sort the list prime_numbers.sort() print(prime_numbers) # >>> [2, 3, 5, 7, 11]","title":"Python Keywords"},{"location":"leetcode/bfs/01-matrix/","text":"link class Solution: def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]: ROW, COL = len(mat), len(mat[0]) dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] dist = 0 visited = [[0] * ROW for _ in range(COL)]# new ROW*COL matrix res = [[0] * ROW for _ in range(COL)]# new ROW*COL matrix queue = collections.deque() # double ended queue #create new queue with all the zeros from mat for i in range(ROW): for j in range(COL): if mat[i][j] == 0: queue.append((i, j)) visited[i][j] = 1 # since we cannot mark \"-1\" this time # bfs starts here while queue: for i in range(len(queue)): x, y = queue.popleft() if mat[x][y] == 1: res[x][y] = dist for dx, dy in dirs: nx, ny = x + dx, y + dy if nx < 0 or nx >= ROW or ny < 0 or ny >= COL or visited[nx][ny] == 1: continue queue.append((nx, ny)) visited[nx][ny] = 1 dist += 1 return res","title":"01 matrix"},{"location":"leetcode/bfs/rotting-oranges/","text":"leetcode.cn class Solution: def orangesRotting(self, grid: List[List[int]]) -> int: ROW, COL = len(grid), len(grid[0]) dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] count = 0 rotten = {(i,j) for i in range(ROW) for j in range(COL) if grid[i][j]==2} fresh = {(i,j) for i in range(ROW) for j in range(COL) if grid[i][j]==1} if not fresh: return 0 # bfs starts here while fresh: if not rotten: return -1 rotten = {(i + di, j + dj) for i, j in rotten for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)] if (i + di, j + dj) in fresh} fresh -= rotten count += 1 return count","title":"Rotting oranges"},{"location":"leetcode/binary-tree/binary-tree-inorder-traversal/","text":"Tree Traversal preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Binary tree inorder traversal"},{"location":"leetcode/binary-tree/binary-tree-inorder-traversal/#tree-traversal","text":"preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Tree Traversal"},{"location":"leetcode/binary-tree/binary-tree-level-order-traversal/","text":"# https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: self.ret = [] def bfs(node): queue = [node] while queue: self.ret.append([n.val for n in queue]) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return self.ret","title":"Binary tree level order traversal"},{"location":"leetcode/binary-tree/merge-two-binary-trees/","text":"# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode: def dfs(root1,root2): root = TreeNode() if not root1: return root2 elif not root2: return root1 else: root.val = root1.val + root2.val root.left = dfs(root1.left, root2.left) root.right = dfs(root1.right, root2.right) return root return dfs(root1,root2)","title":"Merge two binary trees"},{"location":"leetcode/binary-tree/populating-next-right-pointers-in-each-node/","text":"link \"\"\" # Definition for a Node. class Node: def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None): self.val = val self.left = left self.right = right self.next = next \"\"\" class Solution: def connect(self, root: 'Optional[Node]') -> 'Optional[Node]': # if not root or not root.left or not root.right: return root # ret = root # while ret.left: # head = ret.left # while ret: # ret.left.next = ret.right # if ret.next: # ret.right.next = ret.next.left # ret = ret.next # ret = head # return root def moveNext(nodes): head = nodes[0] for node in nodes[1:]: head.next = node head = node def bfs(node): queue = [node] while queue: moveNext(queue) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return root","title":"Populating next right pointers in each node"},{"location":"leetcode/dfs/flood-fill-myths/","text":"class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ROW = len(image) COL = len(image[0]) valid_pixel = image[sr][sc] dirs = [[0,1],[1,0],[0,-1],[-1,0]] def isValidPosition(x, y): return x >= 0 and y >=0 and x < ROW and y < COL and image[x][y]== valid_pixel def dfs(x, y): if image[x][y] == valid_pixel: image[x][y] = newColor # for nx,ny in [(x,y+1),(x+1,y),(x,y-1),(x-1,y)]: for dx, dy in dirs: nx,ny = x+dx,y+dy if isValidPosition(nx,ny): dfs(nx,ny) if valid_pixel == newColor: return image else: # for r in range(ROW): # for c in range(COL): # if image[r][c] == valid_pixel: dfs(sr, sc) return image","title":"Flood fill myths"},{"location":"leetcode/dfs/flood-fill/","text":"class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ROW = len(image) COL = len(image[0]) valid_pixel = image[sr][sc] def isValidPosition(x, y): return x >= 0 and y >=0 and x < ROW and y < COL and image[x][y]== valid_pixel def dfs(x, y): if image[x][y] == valid_pixel: image[x][y] = newColor for nx,ny in [(x,y+1),(x+1,y),(x,y-1),(x-1,y)]: if isValidPosition(nx,ny): dfs(nx,ny) if valid_pixel != newColor: dfs(sr,sc) return image else: return image","title":"Flood fill"},{"location":"leetcode/dfs/max-area-of-island/","text":"class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = -1 area = [] def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED count = 1 for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): count += dfs(nx,ny) return count for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count1 = dfs(r, c) area.append(count1) if not area: return 0 else: return max(area)","title":"Max area of island"},{"location":"leetcode/dfs/number-of-islands/","text":"# https://leetcode-cn.com/problems/number-of-islands/ class Solution: def numIslands(self, grid: List[List[str]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = '-1' ISLAND = '1' count = 0 def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): dfs(nx, ny) def bfs(x, y): grid[x][y] = VISITED queue = [[x, y]] while queue: new_queue = [] for cx, cy in queue: for dx, dy in dirs: nx, ny = cx+dx, cy+dy if isValidPosition(nx, ny): new_queue.append([nx, ny]) grid[nx][ny] = VISITED queue = new_queue for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count += 1 bfs(r, c) return count","title":"Number of islands"},{"location":"leetcode/dynamic-programming/house-robber/","text":"link class Solution: def rob(self, nums: List[int]) -> int: # dynamic_programming dp = {} # {room : val} dp[0] = nums[0] if len(nums) == 1: return dp[0] dp[1] = max(nums[0], nums[1]) if len(nums) == 2: return dp[1] for room, val in enumerate(nums): #room=2 if room >= 2: dp[room] = max( dp[room-1], val+dp[room-2] ) return max(dp.values())","title":"House robber"},{"location":"leetcode/linked-list/middle-of-the-linked-list/","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def middleNode(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow,fast = slow.next,fast.next.next return slow","title":"Middle of the linked list"},{"location":"leetcode/linked-list/remove-nth-node-from-end-of-list/","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode: def getLength(head: ListNode) -> int: length = 0 while head: length+= 1 head = head.next return length L = getLength(head) # [1,2,3,4,5] L= 5 # if n = 2 the first three nodes are kept the same # we wanna link the third(L-n) node to the fifth(L-n+2) res = ListNode(0,head) cur_node = res for i in range(1,L-n+1): cur_node = cur_node.next cur_node.next = cur_node.next.next return res.next","title":"Remove nth node from end of list"},{"location":"leetcode/linked-list/reverse-linked-list/","text":"Definition for singly-linked list. class ListNode: def init (self, val=0, next=None): self.val = val self.next = next class Solution: def reverseList(self, head: ListNode) -> ListNode: ## sol1: # nums = [] # dummy = ListNode() # dummy.next = head # while head: # nums.append(head.val) # head = head.next # head = dummy.next # for n in nums[::-1]: # head.val = n # head = head.next # return dummy.next ## sol2 def helper(prev, cur): if cur.next: tmp = cur.next cur.next = prev return helper(cur, tmp) else: cur.next = prev return cur if head: return helper(None, head) else: return None","title":"Definition for singly-linked list."},{"location":"leetcode/linked-list/reverse-linked-list/#definition-for-singly-linked-list","text":"","title":"Definition for singly-linked list."},{"location":"leetcode/linked-list/reverse-linked-list/#class-listnode","text":"","title":"class ListNode:"},{"location":"leetcode/linked-list/reverse-linked-list/#def-initself-val0-nextnone","text":"","title":"def init(self, val=0, next=None):"},{"location":"leetcode/linked-list/reverse-linked-list/#selfval-val","text":"","title":"self.val = val"},{"location":"leetcode/linked-list/reverse-linked-list/#selfnext-next","text":"class Solution: def reverseList(self, head: ListNode) -> ListNode: ## sol1: # nums = [] # dummy = ListNode() # dummy.next = head # while head: # nums.append(head.val) # head = head.next # head = dummy.next # for n in nums[::-1]: # head.val = n # head = head.next # return dummy.next ## sol2 def helper(prev, cur): if cur.next: tmp = cur.next cur.next = prev return helper(cur, tmp) else: cur.next = prev return cur if head: return helper(None, head) else: return None","title":"self.next = next"},{"location":"leetcode/list-map/two-sum-ii-input-array-is-sorted/","text":"solution #1 copied codes from two-sum solution #2 tried to two pointers method class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: # Solution #1 # copied codes from two-sum # added \"+1\" when return # needed = {} # for i, n in enumerate(numbers): # if n in needed: # return [needed[n]+1, i+1] # reminder = target - n # needed[reminder] = i # return [-1, -1] #Solution #2 two pointers # i from head to tail # j from tail move backwards i = 0 j = len(numbers)-1 while j>i: val = numbers[j] + numbers[i] if val == target: return[i+1,j+1] elif val > target: j -= 1 else: i += 1 return [-1, -1]","title":"Two sum ii input array is sorted"},{"location":"leetcode/list-map/two-sum/","text":"# https://leetcode-cn.com/problems/two-sum/ class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: # eg # nums = [2,7,11,15], target = 9 # 2 -> [7,11,15] # 7 -> [11,15] # ... ## sol1: # for i, n in enumerate(nums): # for j, m in enumerate(nums): # if j > i: # if n + m == target: # return [i, j] # return [-1, -1] ## sol2: needed = {} for i, n in enumerate(nums): if n in needed: return [needed[n], i] reminder = target - n needed[reminder] = i return [-1, -1] ## demo # i: 1 # n: 7 # needed: {7: 0} # reminder: 7","title":"Two sum"},{"location":"leetcode/regression/merge-two-sorted-lists/","text":"leetcode.cn # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]: if not list1: return list2 if not list2: return list1 if list1.val <= list2.val: list1.next = self.mergeTwoLists(list1.next,list2) return list1 else: list2.next = self.mergeTwoLists(list1,list2.next) return list2","title":"Merge two sorted lists"},{"location":"leetcode/two-pointer/3sum/","text":"class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: nums.sort() n = len(nums) ans = [] if n<3: return ans for i in range(n): if i>0 and nums[i] == nums[i-1]: continue k = n-1 target = 0 - nums[i] for j in range(i+1,n): if j>i+1 and nums[j] == nums[j-1]: continue while j<k and nums[j] + nums[k] > target: k -= 1 if j==k: break if nums[j] + nums[k] == target: ans.append([nums[i],nums[j],nums[k]]) return ans","title":"3sum"},{"location":"leetcode/two-pointer/container-with-most-water/","text":"class Solution: def maxArea(self, height: List[int]) -> int: i = 0 j = len(height)-1 area = [] while j>i: area.append(min(height[i],height[j])*(j-i)) if height[i] <= height[j]: i += 1 else: j -= 1 return max(area) # Sol 1: timed out # for i, n in enumerate(height): # for j,m in enumerate(height): # if n<=m: # area.append(n * (j-i)) # else: # area.append(m * (j-i)) # j += 1 # i += 1 # return max(area)","title":"Container with most water"},{"location":"leetcode/two-pointer/move-zeroes/","text":"class Solution: def moveZeroes(self, nums: List[int]) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" i = 0 j = 0 while i<len(nums): if nums[i] !=0: nums[j],nums[i] = nums[i],nums[j] j += 1 i += 1","title":"Move zeroes"},{"location":"leetcode/two-pointer/remove-duplicates-from-sorted-array/","text":"# https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ class Solution: def removeDuplicates(self, nums: List[int]) -> int: # eg # nums = [0,1,2,3,4,2,2,3,3,4] # nums = [0,1,2,3,1,2,2,3,3,4] # i # j i = 0 j = 0 while j < len(nums): if nums[i] == nums[j]: j += 1 else: i += 1 nums[i] = nums[j] return i + 1","title":"Remove duplicates from sorted array"},{"location":"leetcode/two-pointer/reverse-string/","text":"reverse string as in list class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" i = 0 j = len(s)-1 while j>i: s[j], s[i] = s[i] + s[j] j -= 1 i += 1 reverse string as string \"\" split(\"\") to split \" I love pizza\" as per word list: [\"I\",\"love\",\"pizza\"] split(\"\")[::-1] to reverse each word in list [\"I\",\"evol\",\"azzip\"] .join(split(\"\")[::-1]) to make it as string and .join(split(\"\")[::-1])[::-1] to reverse the whole thing class Solution: def reverseWords(self, s: str) -> str: return \" \".join(s.split(\" \")[::-1])[::-1]","title":"Reverse string"},{"location":"leetcode/two-pointer/reverse-string/#reverse-string-as-in-list","text":"class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" i = 0 j = len(s)-1 while j>i: s[j], s[i] = s[i] + s[j] j -= 1 i += 1","title":"reverse string as in list"},{"location":"leetcode/two-pointer/reverse-string/#reverse-string-as-string","text":"split(\"\") to split \" I love pizza\" as per word list: [\"I\",\"love\",\"pizza\"] split(\"\")[::-1] to reverse each word in list [\"I\",\"evol\",\"azzip\"] .join(split(\"\")[::-1]) to make it as string and .join(split(\"\")[::-1])[::-1] to reverse the whole thing class Solution: def reverseWords(self, s: str) -> str: return \" \".join(s.split(\" \")[::-1])[::-1]","title":"reverse string as string \"\""},{"location":"leetcode/two-pointer/rotate-array/","text":"did not use two pointer method lol the array was slides and added afterwards class Solution: def rotate(self, nums: List[int], k: int) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) if k > 0: reminder = n - k % n nums[:] = nums[reminder:] + nums[:reminder] else: nums[:] = nums[:]","title":"Rotate array"},{"location":"leetcode/two-pointer/squares-of-a-sorted-array/","text":"class Solution: def sortedSquares(self, nums: List[int]) -> List[int]: i = 0 j = len(nums)-1 k = len(nums)-1 nums_squared = [0]*len(nums) while i<= j: if nums[i] *nums[i] > nums[j] * nums[j]: nums_squared[k] = nums[i] *nums[i] i += 1 else: nums_squared[k] = nums[j] *nums[j] j -= 1 k -=1 return nums_squared","title":"Squares of a sorted array"},{"location":"leetcode/two-pointer/binary-search/binary-search/","text":"# https://leetcode-cn.com/problems/binary-search/ class Solution: def search(self, nums: List[int], target: int) -> int: # eg # nums = [-1,0,3,5,9,12], n = 5 # pivot = 2, val = 3 -> [3...4...5] # pivot = 4, val = 9 i = 0 j = len(nums) -1 while j - i > 1: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot - 1 elif val < target: i = pivot + 1 else: return pivot if nums[i] == target: return i elif nums[j] == target: return j else: return -1","title":"Binary search"},{"location":"leetcode/two-pointer/binary-search/first-bad-version/","text":"# https://leetcode-cn.com/problems/first-bad-version/ # The isBadVersion API is already defined for you. # @param version, an integer # @return an integer # def isBadVersion(version): class Solution: def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" i = 1 j = n while j - i > 1: pivot = (j - i) // 2 + i if isBadVersion(pivot): j = pivot else: i = pivot + 1 if isBadVersion(i): return i else: return j","title":"First bad version"},{"location":"leetcode/two-pointer/binary-search/search-insert-position/","text":"class Solution: def searchInsert(self, nums: List[int], target: int) -> int: i = 0 j = len(nums) -1 if nums[i] >= target: return i elif nums[j] < target: return j +1 while j-i >1: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot elif val < target: i = pivot else: return pivot return j","title":"Search insert position"},{"location":"leetcode/two-pointer/slicing-window/longest-substring-without-repeating-characters/","text":"link class Solution: def lengthOfLongestSubstring(self, s: str) -> int: ## sol 1: # ret = 0 # n = len(s) # def isUnique(word): # return len(word) == len(set(list(word))) # for i in range(n): # for j in range(i, n): # guess = s[i:j+1] # if isUnique(guess): # ret = max(ret, len(guess)) # return ret ## sol 2: # acbc # [a]cbc, {a: 0}, i=0,j=0 # [ac]bc, {a:0, c:1}, i=0,j=1 # [acb]c, {a:0, c:1, b:2}, i=0,j=2 # ac[bc], {a:0, c:1, b:2}, c:3, i=1+1=2, j=3 ret = 0 j = 0 i = 0 dic = {} # {char: index} while j < len(s): char = s[j] if char in dic: new_i = dic[char] + 1 if new_i > i: i = new_i dic[char] = j # print(s[i:j+1]) ret = max(ret, j-i+1) j += 1 return ret","title":"Longest substring without repeating characters"},{"location":"mkdocs/config/","text":"Config","title":"Config"},{"location":"mkdocs/config/#config","text":"","title":"Config"},{"location":"mkdocs/usage/","text":"Usage","title":"Usage"},{"location":"mkdocs/usage/#usage","text":"","title":"Usage"}]}
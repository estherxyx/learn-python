{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"estherxyx.github.io/learn-python Intro This is blog about my python study footprint Hello World from estherxyx :","title":"Home"},{"location":"#estherxyxgithubiolearn-python","text":"","title":"estherxyx.github.io/learn-python"},{"location":"#intro","text":"This is blog about my python study footprint Hello World from estherxyx :","title":"Intro"},{"location":"backend/keywords/","text":"Cloud Services Storge In memory data File data csv Database Schema {age: int, name: str, ...} SQL, NoSQL Compute Access Control","title":"Cloud Services"},{"location":"backend/keywords/#cloud-services","text":"","title":"Cloud Services"},{"location":"backend/keywords/#storge","text":"In memory data File data csv Database Schema {age: int, name: str, ...} SQL, NoSQL","title":"Storge"},{"location":"backend/keywords/#compute","text":"","title":"Compute"},{"location":"backend/keywords/#access-control","text":"","title":"Access Control"},{"location":"frontend/Redux/","text":"Frontend state management - What is Redux? single source of truth","title":"Redux"},{"location":"frontend/Redux/#frontend-state-management","text":"","title":"Frontend state management"},{"location":"frontend/Redux/#-what-is-redux-single-source-of-truth","text":"","title":"- What is Redux? single source of truth"},{"location":"frontend/react-basics/","text":"React history Why do we need react? Time Complexity for React? O(n) How did we manage DOM before react? [TODO] What is DOM? UI components What is the benefit of using component? JSX How did we manage DOM before JSX? How did JSX works? Virtual DOM and Key Prop How does React implement Virtual DOM? Why React need key prop? and What is it for? HigherOrderComponent What is HigherOrderComponent? What are the benefits to use HigherOrderComponent? Context API (React 16.3) Why we need Context API? [TODO]: 03.09 how does consumer get the props value? scaffolding Examples of scaffolding in react? Packaging Why we need packaging for frontend? (webpack)","title":"React basics"},{"location":"frontend/react-basics/#react-history","text":"Why do we need react? Time Complexity for React? O(n) How did we manage DOM before react? [TODO] What is DOM?","title":"React history"},{"location":"frontend/react-basics/#ui-components","text":"What is the benefit of using component?","title":"UI components"},{"location":"frontend/react-basics/#jsx","text":"How did we manage DOM before JSX? How did JSX works?","title":"JSX"},{"location":"frontend/react-basics/#virtual-dom-and-key-prop","text":"How does React implement Virtual DOM? Why React need key prop? and What is it for?","title":"Virtual DOM and Key Prop"},{"location":"frontend/react-basics/#higherordercomponent","text":"What is HigherOrderComponent? What are the benefits to use HigherOrderComponent?","title":"HigherOrderComponent"},{"location":"frontend/react-basics/#context-api-react-163","text":"Why we need Context API? [TODO]: 03.09 how does consumer get the props value?","title":"Context API (React 16.3)"},{"location":"frontend/react-basics/#scaffolding","text":"Examples of scaffolding in react?","title":"scaffolding"},{"location":"frontend/react-basics/#packaging","text":"Why we need packaging for frontend? (webpack)","title":"Packaging"},{"location":"leetcode/data-structure/","text":"WIP leetcode::study-plan::algorithms OOD - object-oriented-design # Instance -> Class # Instance -> method/function, attribute/property # Object -> JSON -> {\"name\": \"Andy\"} class Car: def __init__(self, brand): self.speed = 0 self.val = 2 self.brand = brand def run(self, speed): self.speed = speed class Truck(Car): def __init__(self, brand): super(brand) self.load = 200 car1 = Car(\"brand1\") # {\"speed\": 0, \"brand\": \"brand1\"} car2 = Car(\"brand2\") # {\"speed\": 0, \"brand\": \"brand2\"} print(car1.speed) # 0 car1.run(10) print(car1.speed) # 10 car1 = Truck(\"brand1\") class Person: def __init__(self, dna=\"\", child=None): self.dna = dna self.child = child p1 = Person(\"aaaa\") p2 = Person(\"bbbb\") p3 = Person(\"cccc\") p1.child = p2 p2.child = p3 def reverseList(self, person: Person) -> Person: people = [] # [\"aaaa\",] god = Person() god.child = person while person: #p3 people.append(person.dna) person = person.child p1 = god.child reverseList(p1) Big-O O(1) O(n) : number of elements -> n O(n^2) Python Keywords # enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango'] # setting up new array with length n ouside of loops nums = [0]*length # inside the loop no \"append\" or self needed # see eg in squares-of-a-sorted-array # sort() # returns the ordered array from min to max prime_numbers = [11, 3, 7, 5, 2] # sort the list prime_numbers.sort() print(prime_numbers) # >>> [2, 3, 5, 7, 11]","title":"Data structure"},{"location":"leetcode/data-structure/#wip","text":"leetcode::study-plan::algorithms","title":"WIP"},{"location":"leetcode/data-structure/#ood-object-oriented-design","text":"# Instance -> Class # Instance -> method/function, attribute/property # Object -> JSON -> {\"name\": \"Andy\"} class Car: def __init__(self, brand): self.speed = 0 self.val = 2 self.brand = brand def run(self, speed): self.speed = speed class Truck(Car): def __init__(self, brand): super(brand) self.load = 200 car1 = Car(\"brand1\") # {\"speed\": 0, \"brand\": \"brand1\"} car2 = Car(\"brand2\") # {\"speed\": 0, \"brand\": \"brand2\"} print(car1.speed) # 0 car1.run(10) print(car1.speed) # 10 car1 = Truck(\"brand1\") class Person: def __init__(self, dna=\"\", child=None): self.dna = dna self.child = child p1 = Person(\"aaaa\") p2 = Person(\"bbbb\") p3 = Person(\"cccc\") p1.child = p2 p2.child = p3 def reverseList(self, person: Person) -> Person: people = [] # [\"aaaa\",] god = Person() god.child = person while person: #p3 people.append(person.dna) person = person.child p1 = god.child reverseList(p1)","title":"OOD - object-oriented-design"},{"location":"leetcode/data-structure/#big-o","text":"O(1) O(n) : number of elements -> n O(n^2)","title":"Big-O"},{"location":"leetcode/data-structure/#python-keywords","text":"# enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango'] # setting up new array with length n ouside of loops nums = [0]*length # inside the loop no \"append\" or self needed # see eg in squares-of-a-sorted-array # sort() # returns the ordered array from min to max prime_numbers = [11, 3, 7, 5, 2] # sort the list prime_numbers.sort() print(prime_numbers) # >>> [2, 3, 5, 7, 11]","title":"Python Keywords"},{"location":"leetcode/python-operators/","text":"Bitwise Operators in python ~ operator ~12 # >>> -13 # bit complement of 12 # bin(12): 00001100 # ~bin(12):11110011 # 2's complement of -13 is 11110011 & operator (bitwise 'and') 12&13 # >>> 12 # 00001100 # & 00001101 # = 00001100 # therefor 12 | operator (bitwise 'or') 12|13 # >>> 13 # 00001100 # | 00001101 # = 00001101 # therefor 13 ^ operator (bitwise 'xor') 12^13 # >>> 1 # 00001100 # ^ 00001101 # = 00000001 # therefor 1 << operator (leftshift for how many bits) 10<<2 # >>> 40 # bin(10) : 00001010 # <<2 : 0000101000 (two more zeros on the right side) # therefore 40 in decimal >> operator (rightshift for how many bits) 10>>2 # >>> 2 # bin(10) : 00001010 # <<2 : 000010 # therefore 2 in decimal","title":"Python operators"},{"location":"leetcode/python-operators/#bitwise-operators-in-python","text":"","title":"Bitwise Operators in python"},{"location":"leetcode/python-operators/#operator","text":"~12 # >>> -13 # bit complement of 12 # bin(12): 00001100 # ~bin(12):11110011 # 2's complement of -13 is 11110011","title":"~ operator"},{"location":"leetcode/python-operators/#operator-bitwise-and","text":"12&13 # >>> 12 # 00001100 # & 00001101 # = 00001100 # therefor 12","title":"&amp; operator (bitwise 'and')"},{"location":"leetcode/python-operators/#operator-bitwise-or","text":"12|13 # >>> 13 # 00001100 # | 00001101 # = 00001101 # therefor 13","title":"| operator (bitwise 'or')"},{"location":"leetcode/python-operators/#operator-bitwise-xor","text":"12^13 # >>> 1 # 00001100 # ^ 00001101 # = 00000001 # therefor 1","title":"^ operator (bitwise 'xor')"},{"location":"leetcode/python-operators/#operator-leftshift-for-how-many-bits","text":"10<<2 # >>> 40 # bin(10) : 00001010 # <<2 : 0000101000 (two more zeros on the right side) # therefore 40 in decimal","title":"&lt;&lt; operator (leftshift for how many bits)"},{"location":"leetcode/python-operators/#operator-rightshift-for-how-many-bits","text":"10>>2 # >>> 2 # bin(10) : 00001010 # <<2 : 000010 # therefore 2 in decimal","title":"&gt;&gt; operator (rightshift for how many bits)"},{"location":"leetcode/bfs/01-matrix/","text":"link class Solution: def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]: ROW, COL = len(mat), len(mat[0]) dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] dist = 0 visited = [[0] * ROW for _ in range(COL)]# new ROW*COL matrix res = [[0] * ROW for _ in range(COL)]# new ROW*COL matrix queue = collections.deque() # double ended queue #create new queue with all the zeros from mat for i in range(ROW): for j in range(COL): if mat[i][j] == 0: queue.append((i, j)) visited[i][j] = 1 # since we cannot mark \"-1\" this time # bfs starts here while queue: for i in range(len(queue)): x, y = queue.popleft() if mat[x][y] == 1: res[x][y] = dist for dx, dy in dirs: nx, ny = x + dx, y + dy if nx < 0 or nx >= ROW or ny < 0 or ny >= COL or visited[nx][ny] == 1: continue queue.append((nx, ny)) visited[nx][ny] = 1 dist += 1 return res","title":"01 matrix"},{"location":"leetcode/bfs/color-fill-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/color-fill-lcci/submissions/] class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: #dfs #bfs ROW = len(image) COL = len(image[0]) entry_pixel = image[sr][sc] directions = [[1,0],[-1,0],[0,1],[0,-1]] def isValidPixel(r,c): return r >= 0 and c >= 0 and r < ROW and c < COL and image[r][c]== entry_pixel def dfs(x,y): if image[x][y] == entry_pixel: image[x][y] = newColor for dx, dy in directions: nx,ny = x+dx, y+dy if isValidPixel(nx,ny): dfs(nx,ny) def bfs(x,y): if image[x][y] == entry_pixel: image[x][y] = newColor queue = [[x,y]] while queue: new_queue = [] for cx, cy in queue: for dx, dy in directions: nx,ny = cx+dx, cy+dy if isValidPixel(nx,ny): new_queue.append([nx,ny]) image[nx][ny] = newColor queue = new_queue if entry_pixel==newColor: return image else: # dfs(sr,sc) bfs(sr,sc) return image","title":"Color fill lcci"},{"location":"leetcode/bfs/rotting-oranges/","text":"leetcode.cn class Solution: def orangesRotting(self, grid: List[List[int]]) -> int: ROW, COL = len(grid), len(grid[0]) dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] count = 0 rotten = {(i,j) for i in range(ROW) for j in range(COL) if grid[i][j]==2} fresh = {(i,j) for i in range(ROW) for j in range(COL) if grid[i][j]==1} if not fresh: return 0 # bfs starts here while fresh: if not rotten: return -1 rotten = {(i + di, j + dj) for i, j in rotten for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)] if (i + di, j + dj) in fresh} fresh -= rotten count += 1 return count","title":"Rotting oranges"},{"location":"leetcode/bfs/route-between-nodes-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/route-between-nodes-lcci/submissions/] class Solution: def findWhetherExistsPath(self, n: int, graph: List[List[int]], start: int, target: int) -> bool: # dirs = [[0,1],[1,0],[0,-1],[-1,0]] # ROW = len(graph) # COL = len(graph[0]) # starting_xy = [] # for r in range(ROW): # for c in range(COL): # if graph[r][c]==start: # starting_xy.append([r,c]) # def isValidPosition(x, y): # return x >= 0 and y >= 0 and x < ROW and y < COL and graph[x][y] == start # def bfs(starting_xy) -> bool: # graph[x][y] = start # queue = starting_xy # while queue: # new_queue = [] # for cx, cy in queue: # for dx, dy in dirs: # nx, ny = cx+dx, cy+dy # if isValidPosition(nx, ny): # new_queue.append([nx, ny]) # graph[nx][ny] = start # queue = new_queue # return res dic = collections.defaultdict(list) for r, c in graph: dic[r].append(c) visited = set() queue = deque() queue.append(start) while queue: pos = queue.popleft() if pos == target: return True for _next in dic[pos]: if _next not in visited: visited.add(_next) queue.append(_next) return False","title":"Route between nodes lcci"},{"location":"leetcode/binary-tree/binary-tree-inorder-traversal/","text":"Tree Traversal preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Binary tree inorder traversal"},{"location":"leetcode/binary-tree/binary-tree-inorder-traversal/#tree-traversal","text":"preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Tree Traversal"},{"location":"leetcode/binary-tree/binary-tree-level-order-traversal/","text":"# https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: self.ret = [] def bfs(node): queue = [node] while queue: self.ret.append([n.val for n in queue]) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return self.ret","title":"Binary tree level order traversal"},{"location":"leetcode/binary-tree/check-subtree-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/check-subtree-lcci/submissions/] # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def checkSubTree(self, t1: TreeNode, t2: TreeNode) -> bool: def tree_dfs(t1,t2): if not t2: return True elif t1== None and t2!= None: return False elif t1.val != t2.val: return False else: return tree_dfs(t1.left,t2.left) and tree_dfs(t1.right,t2.right) if not t2: return True elif not t1: return False else: return tree_dfs(t1,t2) or self.checkSubTree(t1.left,t2) or self.checkSubTree(t1.right,t2)","title":"Check subtree lcci"},{"location":"leetcode/binary-tree/first-common-ancestor-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/first-common-ancestor-lcci/solution/] # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: if not root or root==p or root==q: return root #dfs left = self.lowestCommonAncestor(root.left,p,q) right = self.lowestCommonAncestor(root.right,p,q) if left and right: return root return left if left else right","title":"First common ancestor lcci"},{"location":"leetcode/binary-tree/legal-binary-search-tree-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/submissions/] # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isValidBST(self, root: TreeNode) -> bool: ret = [] def inorderTraversal(root): if root: inorderTraversal(root.left) ret.append(root.val) inorderTraversal(root.right) # return ret inorderTraversal(root) return ret == sorted(set(ret))","title":"Legal binary search tree lcci"},{"location":"leetcode/binary-tree/merge-two-binary-trees/","text":"# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode: def dfs(root1,root2): root = TreeNode() if not root1: return root2 elif not root2: return root1 else: root.val = root1.val + root2.val root.left = dfs(root1.left, root2.left) root.right = dfs(root1.right, root2.right) return root return dfs(root1,root2)","title":"Merge two binary trees"},{"location":"leetcode/binary-tree/minimum-height-tree-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/minimum-height-tree-lcci/] # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def sortedArrayToBST(self, nums: List[int]) -> TreeNode: if not nums: return None # dfs pivot = len(nums)//2 ret = TreeNode(nums[pivot]) ret.left = self.sortedArrayToBST(nums[:pivot]) ret.right = self.sortedArrayToBST(nums[pivot+1:]) return ret","title":"Minimum height tree lcci"},{"location":"leetcode/binary-tree/populating-next-right-pointers-in-each-node/","text":"link \"\"\" # Definition for a Node. class Node: def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None): self.val = val self.left = left self.right = right self.next = next \"\"\" class Solution: def connect(self, root: 'Optional[Node]') -> 'Optional[Node]': # if not root or not root.left or not root.right: return root # ret = root # while ret.left: # head = ret.left # while ret: # ret.left.next = ret.right # if ret.next: # ret.right.next = ret.next.left # ret = ret.next # ret = head # return root def moveNext(nodes): head = nodes[0] for node in nodes[1:]: head.next = node head = node def bfs(node): queue = [node] while queue: moveNext(queue) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return root","title":"Populating next right pointers in each node"},{"location":"leetcode/binary-tree/successor-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/successor-lcci/submissions/] # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> TreeNode: #binary search #this works due to the property of an inorder bst ret = None cur = root while cur: if cur.val <= p.val: cur = cur.right else: ret = cur cur = cur.left return ret","title":"Successor lcci"},{"location":"leetcode/bit-operation/convert-integer-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/convert-integer-lcci/submissions/] class Solution: def convertInteger(self, A: int, B: int) -> int: c = A ^ B ret = 0 # to find how many \"1\" in c for i in range(32): ret += c>>i&1 #rightshift and find 1 return ret","title":"Convert integer lcci"},{"location":"leetcode/bit-operation/insert-into-bits-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/insert-into-bits-lcci/] class Solution: def insertBits(self, N: int, M: int, i: int, j: int) -> int: # N = 10000000000 # M = 10011 # ret=[1000][10011][00] # i = 2 j = 6 i_n = 0 i_m = 0 n = bin(N)[2:] m = bin(M)[2:] if len(m) == j-i+1: ret = n[:-(j+1)] + m + n[len(n)-i:] else: pivot_str = \"0\"*(j-i+1-len(m)) + m ret = n[:-(j+1)] + pivot_str + n[len(n)-i:] return int(ret,2)","title":"Insert into bits lcci"},{"location":"leetcode/bit-operation/power-of-two/","text":"leetcode.cn class Solution: def isPowerOfTwo(self, n: int) -> bool: # First try: failed lol # bin_n = list(bin(n)[2:]) # this is wrong, we need a string in for loop!! # print(bin_n) # for c in bin_n: # the bin_n has to be a string in this case # count = 0 # if c == \"1\": # count += 1 # return n>0 and count ==1 # second try: worked # return n>0 and bin(n).count(\"1\")==1 # final round: ## if we do \"for c in bin(n)\", the \"bin(n)\" has to be a string not a list!! ret = 0 for c in bin(n): if c == \"1\": ret += 1 return n>0 and ret==1","title":"Power of two"},{"location":"leetcode/bit-operation/reverse-bits-lcci/","text":"leetcode.cc class Solution: def reverseBits(self, num: int) -> int: cur = 0 pivot = 0 ret = 1 # for c in bin(num): # if num and c==\"1\": for i in range(32): if num &(1<<i): cur += 1 pivot += 1 else: pivot = cur +1 cur = 0 ret = max(pivot, ret) return ret","title":"Reverse bits lcci"},{"location":"leetcode/bit-operation/single-number/","text":"leetcode.cn class Solution: def singleNumber(self, nums: List[int]) -> int: n = len(nums) ret = 0 for i in range(n): ret = ret^nums[i] return ret","title":"Single number"},{"location":"leetcode/class/implement-queue-using-stacks-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/submissions/] class MyQueue: # FIFO def __init__(self): self.stack_in = [] self.stack_out = [] def push(self, x: int) -> None: self.stack_in.append(x) def pop(self) -> int: if len(self.stack_out)==0: for i in range(len(self.stack_in)): self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() def peek(self) -> int: if len(self.stack_out)==0: for i in range(len(self.stack_in)): self.stack_out.append(self.stack_in.pop()) temp = self.stack_out.pop() self.stack_out.append(temp) return temp def empty(self) -> bool: return len(self.stack_in)==0 and len(self.stack_out)==0 # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty()","title":"Implement queue using stacks lcci"},{"location":"leetcode/class/min-stack-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/min-stack-lcci/] class MinStack: def __init__(self): self.stack = [] self.MinStack = [math.inf] def push(self, x: int) -> None: self.stack.append(x) self.MinStack.append(min(x,self.MinStack[-1])) def pop(self) -> None: self.stack.pop() self.MinStack.pop() def top(self) -> int: return self.stack[-1] def getMin(self) -> int: return self.MinStack[-1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(x) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin()","title":"Min stack lcci"},{"location":"leetcode/class/stack-of-plates-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/stack-of-plates-lcci/submissions/] class StackOfPlates: def __init__(self, cap: int): self.cap = cap self.arr = [] def push(self, val: int) -> None: if self.cap <= 0: return elif not self.arr or len(self.arr[-1]) == self.cap: self.arr.append([]) self.arr[-1].append(val) else: self.arr[-1].append(val) def pop(self) -> int: if not self.arr: return -1 p = self.arr[-1].pop() if not self.arr[-1]: del self.arr[-1] return p def popAt(self, index: int) -> int: if len(self.arr) < index + 1 : return -1 q = self.arr[index].pop() if not self.arr[index]: del self.arr[index] return q # Your StackOfPlates object will be instantiated and called as such: # obj = StackOfPlates(cap) # obj.push(val) # param_2 = obj.pop() # param_3 = obj.popAt(index)","title":"Stack of plates lcci"},{"location":"leetcode/class/three-in-one-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/three-in-one-lcci/submissions/] ```python ```class TripleInOne: def __init__(self, stackSize: int): self.tripleStack = [[]for i in range(3)] self.stackSize = stackSize def push(self, stackNum: int, value: int) -> None: if len(self.tripleStack[stackNum]) < self.stackSize: self.tripleStack[stackNum].append(value) def pop(self, stackNum: int) -> int: if self.tripleStack[stackNum] != []: popedValue = self.tripleStack[stackNum][-1] self.tripleStack[stackNum] = self.tripleStack[stackNum][:-1] return popedValue else: return -1 def peek(self, stackNum: int) -> int: if self.tripleStack[stackNum] != []: popedValue = self.tripleStack[stackNum][-1] return popedValue else: return -1 def isEmpty(self, stackNum: int) -> bool: return self.tripleStack[stackNum] == [] Your TripleInOne object will be instantiated and called as such: obj = TripleInOne(stackSize) obj.push(stackNum,value) param_2 = obj.pop(stackNum) param_3 = obj.peek(stackNum) param_4 = obj.isEmpty(stackNum)","title":"Three in one lcci"},{"location":"leetcode/class/three-in-one-lcci/#your-tripleinone-object-will-be-instantiated-and-called-as-such","text":"","title":"Your TripleInOne object will be instantiated and called as such:"},{"location":"leetcode/class/three-in-one-lcci/#obj-tripleinonestacksize","text":"","title":"obj = TripleInOne(stackSize)"},{"location":"leetcode/class/three-in-one-lcci/#objpushstacknumvalue","text":"","title":"obj.push(stackNum,value)"},{"location":"leetcode/class/three-in-one-lcci/#param_2-objpopstacknum","text":"","title":"param_2 = obj.pop(stackNum)"},{"location":"leetcode/class/three-in-one-lcci/#param_3-objpeekstacknum","text":"","title":"param_3 = obj.peek(stackNum)"},{"location":"leetcode/class/three-in-one-lcci/#param_4-objisemptystacknum","text":"","title":"param_4 = obj.isEmpty(stackNum)"},{"location":"leetcode/dfs/flood-fill-myths/","text":"class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ROW = len(image) COL = len(image[0]) valid_pixel = image[sr][sc] dirs = [[0,1],[1,0],[0,-1],[-1,0]] def isValidPosition(x, y): return x >= 0 and y >=0 and x < ROW and y < COL and image[x][y]== valid_pixel def dfs(x, y): if image[x][y] == valid_pixel: image[x][y] = newColor # for nx,ny in [(x,y+1),(x+1,y),(x,y-1),(x-1,y)]: for dx, dy in dirs: nx,ny = x+dx,y+dy if isValidPosition(nx,ny): dfs(nx,ny) if valid_pixel == newColor: return image else: # for r in range(ROW): # for c in range(COL): # if image[r][c] == valid_pixel: dfs(sr, sc) return image","title":"Flood fill myths"},{"location":"leetcode/dfs/flood-fill/","text":"class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ROW = len(image) COL = len(image[0]) valid_pixel = image[sr][sc] def isValidPosition(x, y): return x >= 0 and y >=0 and x < ROW and y < COL and image[x][y]== valid_pixel def dfs(x, y): if image[x][y] == valid_pixel: image[x][y] = newColor for nx,ny in [(x,y+1),(x+1,y),(x,y-1),(x-1,y)]: if isValidPosition(nx,ny): dfs(nx,ny) if valid_pixel != newColor: dfs(sr,sc) return image else: return image","title":"Flood fill"},{"location":"leetcode/dfs/max-area-of-island/","text":"class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = -1 area = [] def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED count = 1 for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): count += dfs(nx,ny) return count for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count1 = dfs(r, c) area.append(count1) if not area: return 0 else: return max(area)","title":"Max area of island"},{"location":"leetcode/dfs/number-of-islands/","text":"# https://leetcode-cn.com/problems/number-of-islands/ class Solution: def numIslands(self, grid: List[List[str]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = '-1' ISLAND = '1' count = 0 def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): dfs(nx, ny) def bfs(x, y): grid[x][y] = VISITED queue = [[x, y]] while queue: new_queue = [] for cx, cy in queue: for dx, dy in dirs: nx, ny = cx+dx, cy+dy if isValidPosition(nx, ny): new_queue.append([nx, ny]) grid[nx][ny] = VISITED queue = new_queue for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count += 1 bfs(r, c) return count","title":"Number of islands"},{"location":"leetcode/dynamic-programming/climbing-stairs/","text":"leetcode.cn class Solution: def climbStairs(self, n: int) -> int: # dynamic_programming # dp = {1:1, 2:2, 3:3} dp = [0]*(n+2) dp[1] = 1 dp[2] = 2 if n<=2: return n i = 3 while i <= n+1: if n>=3: dp[i] = dp[i-1]+ dp[i-2] i += 1 return dp[n]","title":"Climbing stairs"},{"location":"leetcode/dynamic-programming/contiguous-sequence-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/contiguous-sequence-lcci/] class Solution: def maxSubArray(self, nums: List[int]) -> int: if not nums: return None _max = nums[0] cur = nums[0] for i in range(1,len(nums)): cur = max(cur+nums[i],nums[i]) _max = max(_max,cur) return _max","title":"Contiguous sequence lcci"},{"location":"leetcode/dynamic-programming/house-robber/","text":"link class Solution: def rob(self, nums: List[int]) -> int: # dynamic_programming dp = {} # {room : val} dp[0] = nums[0] if len(nums) == 1: return dp[0] dp[1] = max(nums[0], nums[1]) if len(nums) == 2: return dp[1] for room, val in enumerate(nums): #room=2 if room >= 2: dp[room] = max( dp[room-1], val+dp[room-2] ) return max(dp.values())","title":"House robber"},{"location":"leetcode/dynamic-programming/the-masseuse-lcci/","text":"(leetcode)[https://leetcode-cn.com/problems/the-masseuse-lcci/] class Solution: def massage(self, nums: List[int]) -> int: ## exact same code as housing robbing # dynamic_programming if not nums: return 0 dp = {} dp[0] = nums[0] if len(nums) == 1: return dp[0] dp[1] = max(nums[0], nums[1]) if len(nums) == 2: return dp[1] for room, val in enumerate(nums): #room=2 if room >= 2: dp[room] = max( dp[room-1], val+dp[room-2] ) return max(dp.values())","title":"The masseuse lcci"},{"location":"leetcode/dynamic-programming/three-steps-problem-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/three-steps-problem-lcci/submissions/] class Solution: def waysToStep(self, n: int) -> int: if n<=2: return n mod = 1000000007 dp = [0]*(n+1) dp[0] = 1 dp[1] = 1 dp[2] = 2 for i in range(3,n+1): dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % mod return dp[n]","title":"Three steps problem lcci"},{"location":"leetcode/leetcodecn-contests/keep-multiplying-found-values-by-two/","text":"(leetcode.contest)[https://leetcode-cn.com/contest/weekly-contest-278/problems/keep-multiplying-found-values-by-two/] for i in range(len(nums)): while original in nums: original = original*2 return original","title":"Keep multiplying found values by two"},{"location":"leetcode/leetcodecn-contests/https%3A/leetcode-cn.com/coall-divisions-with-the-highest-score-of-a-binary-array/","text":"(leetcode.contest)[https://leetcode-cn.com/contest/weekly-contest-278/problems/all-divisions-with-the-highest-score-of-a-binary-array/] class Solution: def maxScoreIndices(self, nums: List[int]) -> List[int]: # # 0,0,1,0 n = len(nums) dp = {}# {i:score} dp[0] = nums.count(1) ret = [] _max = 0 for i in range(n): if i >=1: score = nums[:i-1].count(0) + nums[i:].count(1) dp[i] = score _max = max(dp[i-1],dp[i]) for i in range(n): if i>=1 and nums[:i-1].count(0) + nums[i:].count(1)==_max: ret.append(i+1) return ret # l = 0 # r = sum(nums) # dic = {l+r: [0]} # {score: [index]} # _max = l+r # for i, n in enumerate(nums): # if n == 0: # l += 1 # elif n == 1: # r -= 1 # score = l+r # if score not in dic: # dic[score] = [] # dic[score].append(i+1) # _max = max(_max, score) # # print(dic) # return dic[_max]","title":"Coall divisions with the highest score of a binary array"},{"location":"leetcode/linked-list/delete-middle-node-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/delete-middle-node-lcci/] # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node.val = node.next.val node.next = node.next.next","title":"Delete middle node lcci"},{"location":"leetcode/linked-list/kth-node-from-end-of-list-lcci/","text":"(leetcode)[https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/] # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def kthToLast(self, head: ListNode, k: int) -> int: values = [] while head: values.append(head.val) head = head.next n = len(values) return values[n-k]","title":"Kth node from end of list lcci"},{"location":"leetcode/linked-list/middle-of-the-linked-list/","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def middleNode(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow,fast = slow.next,fast.next.next return slow","title":"Middle of the linked list"},{"location":"leetcode/linked-list/palindrome-linked-list-lcci/","text":"leetcode.md # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def isPalindrome(self, head: ListNode) -> bool: # # Solution #1 # ret = [] # while head: # ret.append(head.val) # head = head.next # return ret==ret[::-1] # Solution #2 # find the middle point of the list # reverse the latter part of the list # compare the first half and reversed the list if not head: return True def findMiddle(head): slow, fast = head, head while fast.next.next and fast.next: slow = slow.next fast = fast.next.next return slow def reverseList(head): prev = None cur = head while cur: _next= cur.next cur.next = prev prev = cur cur = _next return prev first_half = findMiddle(head) second_half = reverseList(first_half.next) first = head second = second_half while first and second: if first.val !=second.val: return False first = first.next second = second.next return True","title":"Palindrome linked list lcci"},{"location":"leetcode/linked-list/remove-duplicate-node-lcci/","text":"leetcode.cc # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeDuplicateNodes(self, head: ListNode) -> ListNode: if not head: return head dic = set() cur = head pre = None while cur: if cur.val in dic: pre.next = cur.next else: dic.add(cur.val) pre = cur cur = cur.next return head","title":"Remove duplicate node lcci"},{"location":"leetcode/linked-list/remove-nth-node-from-end-of-list/","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode: def getLength(head: ListNode) -> int: length = 0 while head: length+= 1 head = head.next return length L = getLength(head) # [1,2,3,4,5] L= 5 # if n = 2 the first three nodes are kept the same # we wanna link the third(L-n) node to the fifth(L-n+2) res = ListNode(0,head) cur_node = res for i in range(1,L-n+1): cur_node = cur_node.next cur_node.next = cur_node.next.next return res.next","title":"Remove nth node from end of list"},{"location":"leetcode/list-map/diving-board-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/diving-board-lcci/submissions/] class Solution: def divingBoard(self, shorter: int, longer: int, k: int) -> List[int]: if not k: return [] if shorter==longer: return [shorter*k] res = [0]*(k+1) for i in range(k+1): res[i] = shorter*(k-i) +longer*i return res","title":"Diving board lcci"},{"location":"leetcode/list-map/find-majority-element-lcci/","text":"(leetcode)[https://leetcode-cn.com/problems/find-majority-element-lcci/submissions/] class Solution: def majorityElement(self, nums: List[int]) -> int: res = -1 count = 0 for n in nums: if not count: res = n if n == res: count += 1 else: count -= 1 return res if count and nums.count(res)> len(nums)//2 else -1","title":"Find majority element lcci"},{"location":"leetcode/list-map/missing-number-lcci/","text":"(leetcode)[https://leetcode-cn.com/problems/missing-number-lcci/submissions/] class Solution: def missingNumber(self, nums: List[int]) -> int: # #solution #1 # i = 0 # n = len(nums) # while i <=n: # if i in nums: # i += 1 # else: # return i # # solution #2 # return sum(range(len(nums)+1))-sum(nums) # solution #3 nums.sort() i = 0 n = len(nums) if n != nums[n-1]: return n while i<=n: if i == nums[i]: i +=1 else: return i","title":"Missing number lcci"},{"location":"leetcode/list-map/two-sum-ii-input-array-is-sorted/","text":"solution #1 copied codes from two-sum solution #2 tried to two pointers method class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: # Solution #1 # copied codes from two-sum # added \"+1\" when return # needed = {} # for i, n in enumerate(numbers): # if n in needed: # return [needed[n]+1, i+1] # reminder = target - n # needed[reminder] = i # return [-1, -1] #Solution #2 two pointers # i from head to tail # j from tail move backwards i = 0 j = len(numbers)-1 while j>i: val = numbers[j] + numbers[i] if val == target: return[i+1,j+1] elif val > target: j -= 1 else: i += 1 return [-1, -1]","title":"Two sum ii input array is sorted"},{"location":"leetcode/list-map/two-sum/","text":"# https://leetcode-cn.com/problems/two-sum/ class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: # eg # nums = [2,7,11,15], target = 9 # 2 -> [7,11,15] # 7 -> [11,15] # ... ## sol1: # for i, n in enumerate(nums): # for j, m in enumerate(nums): # if j > i: # if n + m == target: # return [i, j] # return [-1, -1] ## sol2: needed = {} for i, n in enumerate(nums): if n in needed: return [needed[n], i] reminder = target - n needed[reminder] = i return [-1, -1] ## demo # i: 1 # n: 7 # needed: {7: 0} # reminder: 7","title":"Two sum"},{"location":"leetcode/list-map/words-frequency-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/words-frequency-lcci/] class WordsFrequency: #solution #1 dict {key,value} def __init__(self, book: List[str]): self.words = {} for w in book: if w not in self.words.keys(): self.words[w] = 1 else: self.words[w] += 1 def get(self, word: str) -> int: if word not in self.words.keys(): return 0 else: return self.words[word] # # solution #2 timedout # def __init__(self, book: List[str]): # self.book = book # def get(self, word: str) -> int: # return self.book.count(word) # \u8fd9\u6837\u4e0d\u884c \u4f1a\u7206\u6389 # Your WordsFrequency object will be instantiated and called as such: # obj = WordsFrequency(book) # param_1 = obj.get(word)","title":"Words frequency lcci"},{"location":"leetcode/recursion/combinations/","text":"leetcode.cn class Solution: def combine(self, n: int, k: int) -> List[List[int]]: res = [] def helper(start,route): if len(route) == k: res.append(route[:]) return res for i in range(start, n+1): route.append(i) helper(i+1, route) route.pop() helper(1, []) return res","title":"Combinations"},{"location":"leetcode/recursion/hanota-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/hanota-lcci/submissions/] class Solution: def hanota(self, A: List[int], B: List[int], C: List[int]) -> None: \"\"\" Do not return anything, modify C in-place instead. # \"\"\" n = len(A) self.move_hanota(n,A,B,C) def move_hanota(self,n,A,B,C): if n ==1: C.append(A[-1]) A.pop() return else: self.move_hanota(n-1,A,C,B) C.append(A[-1]) A.pop() self.move_hanota(n-1,B,A,C)","title":"Hanota lcci"},{"location":"leetcode/recursion/merge-two-sorted-lists/","text":"leetcode.cn # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]: if not list1: return list2 if not list2: return list1 if list1.val <= list2.val: list1.next = self.mergeTwoLists(list1.next,list2) return list1 else: list2.next = self.mergeTwoLists(list1,list2.next) return list2","title":"Merge two sorted lists"},{"location":"leetcode/recursion/permutations/","text":"leetcode.cn class Solution: def permute(self, nums: List[int]) -> List[List[int]]: res = [] def helper(nums,tmp): if not nums: res.append(tmp) return for i in range(len(nums)): helper(nums[:i] + nums[i+1:],tmp+[nums[i]]) helper(nums,[]) return res","title":"Permutations"},{"location":"leetcode/recursion/reverse-linked-list/","text":"Definition for singly-linked list. class ListNode: def init (self, val=0, next=None): self.val = val self.next = next class Solution: def reverseList(self, head: ListNode) -> ListNode: ## sol1: # nums = [] # dummy = ListNode() # dummy.next = head # while head: # nums.append(head.val) # head = head.next # head = dummy.next # for n in nums[::-1]: # head.val = n # head = head.next # return dummy.next ## sol2 def helper(prev, cur): if cur.next: tmp = cur.next cur.next = prev return helper(cur, tmp) else: cur.next = prev return cur if head: return helper(None, head) else: return None","title":"Definition for singly-linked list."},{"location":"leetcode/recursion/reverse-linked-list/#definition-for-singly-linked-list","text":"","title":"Definition for singly-linked list."},{"location":"leetcode/recursion/reverse-linked-list/#class-listnode","text":"","title":"class ListNode:"},{"location":"leetcode/recursion/reverse-linked-list/#def-initself-val0-nextnone","text":"","title":"def init(self, val=0, next=None):"},{"location":"leetcode/recursion/reverse-linked-list/#selfval-val","text":"","title":"self.val = val"},{"location":"leetcode/recursion/reverse-linked-list/#selfnext-next","text":"class Solution: def reverseList(self, head: ListNode) -> ListNode: ## sol1: # nums = [] # dummy = ListNode() # dummy.next = head # while head: # nums.append(head.val) # head = head.next # head = dummy.next # for n in nums[::-1]: # head.val = n # head = head.next # return dummy.next ## sol2 def helper(prev, cur): if cur.next: tmp = cur.next cur.next = prev return helper(cur, tmp) else: cur.next = prev return cur if head: return helper(None, head) else: return None","title":"self.next = next"},{"location":"leetcode/recursion/triangle/","text":"leetcode.cn class Solution: def minimumTotal(self, triangle: List[List[int]]) -> int: n = len(triangle) ret = [[0]*n for _ in range(n)] ret[0][0] = triangle[0][0] for i in range(1,n): ret[i][0] = triangle[i][0] + ret[i-1][0] for j in range(1,i): ret[i][j] =triangle[i][j] + min(ret[i-1][j-1], ret[i-1][j]) ret[i][i] = triangle[i][i] + ret[i-1][i-1] return min(ret[n-1])","title":"Triangle"},{"location":"leetcode/set/power-set-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/power-set-lcci/] class Solution: def subsets(self, nums: List[int]) -> List[List[int]]: res = [[],] if not nums: return res for n in nums: res += [i+[n] for i in res] return res","title":"Power set lcci"},{"location":"leetcode/string/check-permutation-lcci/","text":"leetcode.cc class Solution: def CheckPermutation(self, s1: str, s2: str) -> bool: dic1 = [0]*26 dic2 = [0]*26 if len(s1) != len(s2): return False for i in range(len(s1)): dic1[ord(s1[i])-ord(\"a\")] += 1 dic2[ord(s2[i])-ord(\"a\")] += 1 return dic1 ==dic2","title":"Check permutation lcci"},{"location":"leetcode/string/compress-string-lcci/","text":"leetcode.cc class Solution: def compressString(self, S: str) -> str: if not S: return \"\" count = 0 c_0 = S[0] ret = '' for c in S: if c == c_0: count += 1 else: ret += c_0 + str(count) c_0 = c count = 1 ret += c_0 + str(count) if len(ret)>= len(S): return S else: return ret","title":"Compress string lcci"},{"location":"leetcode/string/is-unique-lcci/","text":"leetcode.cc class Solution: def isUnique(self, astr: str) -> bool: # solution #1 astr = sorted(astr) for i in range (1,len(astr)): if astr[i]==astr[i-1]: return False return True # # solution # 2 # return len(set(astr))==len(astr) ## solution #3 dic = [0]*26 for i in range(len(astr)): dic[ord(astr[i])-ord(\"a\")] += 1 for i in range(len(dic)): if dic[i] >1: return False return True","title":"Is unique lcci"},{"location":"leetcode/string/isPalindrome/","text":"(leetcode.top-interview-questions-easy)[https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/] class Solution: def isPalindrome(self, s: str) -> bool: s_lower = \"\" for c in s: if \"a\"<=c<=\"z\" or \"A\"<=c<= \"Z\" or \"0\" <= c <=\"9\": s_lower += c.lower() i = 0 j = len(s_lower) -1 while i <j: if s_lower[i] == s_lower[j]: i += 1 j -=1 else: return False return True","title":"isPalindrome"},{"location":"leetcode/string/longest-common-prefix/","text":"(leetcode.top-interview-questions-easy)[https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnmav1/] class Solution: def longestCommonPrefix(self, strs: List[str]) -> str: if not strs: return \"\" for i in range(len(strs[0])): char = strs[0][i] for j in range(1,len(strs)): if i == len(strs[j]) or strs[j][i] != char: return strs[0][:i] return strs[0]","title":"Longest common prefix"},{"location":"leetcode/string/palindrome-permutation-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/palindrome-permutation-lcci/] class Solution: def canPermutePalindrome(self, s: str) -> bool: count = [i for i in Counter(s).values() if i%2 == 1] return len(count) < 2","title":"Palindrome permutation lcci"},{"location":"leetcode/string/permutation-i-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/permutation-i-lcci/comments/] class Solution: def permutation(self, S: str) -> List[str]: res = [] pivot = \"\" def helper(S,pivot,res)->List[str]: if S == \"\": res.append(pivot) return for i in range(len(S)): cur = S[i] helper(S[:i]+S[i+1:],pivot+cur,res) helper(S,pivot,res) return res","title":"Permutation i lcci"},{"location":"leetcode/string/sparse-array-search-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/sparse-array-search-lcci/submissions/] class Solution: def findString(self, words: List[str], s: str) -> int: if not words: return -1 for i,c in enumerate(words): if c == s: return i return -1","title":"Sparse array search lcci"},{"location":"leetcode/string/string-to-url-lcci/","text":"leetcode.cc class Solution: def replaceSpaces(self, S: str, length: int) -> str: return S[:length].replace(' ', '%20')","title":"String to url lcci"},{"location":"leetcode/two-pointer/3sum/","text":"class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: nums.sort() n = len(nums) ans = [] if n<3: return ans for i in range(n): if i>0 and nums[i] == nums[i-1]: continue k = n-1 target = 0 - nums[i] for j in range(i+1,n): if j>i+1 and nums[j] == nums[j-1]: continue while j<k and nums[j] + nums[k] > target: k -= 1 if j==k: break if nums[j] + nums[k] == target: ans.append([nums[i],nums[j],nums[k]]) return ans","title":"3sum"},{"location":"leetcode/two-pointer/container-with-most-water/","text":"leetcode class Solution: def maxArea(self, height: List[int]) -> int: i = 0 j = len(height)-1 area = [] while j>i: area.append(min(height[i],height[j])*(j-i)) if height[i] <= height[j]: i += 1 else: j -= 1 return max(area) # Sol 1: timed out # for i, n in enumerate(height): # for j,m in enumerate(height): # if n<=m: # area.append(n * (j-i)) # else: # area.append(m * (j-i)) # j += 1 # i += 1 # return max(area)","title":"Container with most water"},{"location":"leetcode/two-pointer/move-zeroes/","text":"class Solution: def moveZeroes(self, nums: List[int]) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" i = 0 j = 0 while i<len(nums): if nums[i] !=0: nums[j],nums[i] = nums[i],nums[j] j += 1 i += 1","title":"Move zeroes"},{"location":"leetcode/two-pointer/remove-duplicates-from-sorted-array/","text":"# https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ class Solution: def removeDuplicates(self, nums: List[int]) -> int: # eg # nums = [0,1,2,3,4,2,2,3,3,4] # nums = [0,1,2,3,1,2,2,3,3,4] # i # j i = 0 j = 0 while j < len(nums): if nums[i] == nums[j]: j += 1 else: i += 1 nums[i] = nums[j] return i + 1","title":"Remove duplicates from sorted array"},{"location":"leetcode/two-pointer/reverse-string/","text":"reverse string as in list class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" i = 0 j = len(s)-1 while j>i: s[j], s[i] = s[i] + s[j] j -= 1 i += 1 reverse string as string \"\" split(\"\") to split \" I love pizza\" as per word list: [\"I\",\"love\",\"pizza\"] split(\"\")[::-1] to reverse each word in list [\"I\",\"evol\",\"azzip\"] .join(split(\"\")[::-1]) to make it as string and .join(split(\"\")[::-1])[::-1] to reverse the whole thing class Solution: def reverseWords(self, s: str) -> str: return \" \".join(s.split(\" \")[::-1])[::-1]","title":"Reverse string"},{"location":"leetcode/two-pointer/reverse-string/#reverse-string-as-in-list","text":"class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" i = 0 j = len(s)-1 while j>i: s[j], s[i] = s[i] + s[j] j -= 1 i += 1","title":"reverse string as in list"},{"location":"leetcode/two-pointer/reverse-string/#reverse-string-as-string","text":"split(\"\") to split \" I love pizza\" as per word list: [\"I\",\"love\",\"pizza\"] split(\"\")[::-1] to reverse each word in list [\"I\",\"evol\",\"azzip\"] .join(split(\"\")[::-1]) to make it as string and .join(split(\"\")[::-1])[::-1] to reverse the whole thing class Solution: def reverseWords(self, s: str) -> str: return \" \".join(s.split(\" \")[::-1])[::-1]","title":"reverse string as string \"\""},{"location":"leetcode/two-pointer/rotate-array/","text":"did not use two pointer method lol the array was slides and added afterwards class Solution: def rotate(self, nums: List[int], k: int) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) if k > 0: reminder = n - k % n nums[:] = nums[reminder:] + nums[:reminder] else: nums[:] = nums[:]","title":"Rotate array"},{"location":"leetcode/two-pointer/rotate-matrix-lcci/","text":"leetcode.cc class Solution: def rotate(self, matrix: List[List[int]]) -> None: \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" # stretegy: horizental flip then diagonal flip # horitzental flip first: n = len(matrix) for i in range(n//2): for j in range(n): matrix[i][j],matrix[n-1-i][j] = matrix[n-1-i][j],matrix[i][j] # diagonal flip for i in range(n): for j in range(i): matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]","title":"Rotate matrix lcci"},{"location":"leetcode/two-pointer/smallest-difference-lcci/","text":"leetcode.cc class Solution: def smallestDifference(self, a: List[int], b: List[int]) -> int: m, n = len(a),len(b) a.sort() b.sort() i, j = 0, 0 ret = float('inf') while i <m and j<n: if a[i]<=b[j]: ret = min(ret,b[j]-a[i]) i += 1 else: ret = min(ret,a[i]-b[j]) j += 1 return ret","title":"Smallest difference lcci"},{"location":"leetcode/two-pointer/sorted-merge-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/sorted-merge-lcci/submissions/] class Solution: def merge(self, A: List[int], m: int, B: List[int], n: int) -> None: \"\"\" Do not return anything, modify A in-place instead. \"\"\" i = 0 j = 0 res = [] while i <m or j<n: if i==m: res.append(B[j]) j += 1 elif j==n: res.append(A[i]) i += 1 elif A[i] <= B[j]: res.append(A[i]) i += 1 else: res.append(B[j]) j += 1 A[:] = res return","title":"Sorted merge lcci"},{"location":"leetcode/two-pointer/squares-of-a-sorted-array/","text":"class Solution: def sortedSquares(self, nums: List[int]) -> List[int]: i = 0 j = len(nums)-1 k = len(nums)-1 nums_squared = [0]*len(nums) while i<= j: if nums[i] *nums[i] > nums[j] * nums[j]: nums_squared[k] = nums[i] *nums[i] i += 1 else: nums_squared[k] = nums[j] *nums[j] j -= 1 k -=1 return nums_squared","title":"Squares of a sorted array"},{"location":"leetcode/two-pointer/zero-matrix-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/zero-matrix-lcci/submissions/] class Solution: def setZeroes(self, matrix: List[List[int]]) -> None: \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" n,m = len(matrix),len(matrix[0]) row,col = [0]*n,[0]*m for i in range(n): for j in range(m): if matrix[i][j]==0: row[i] = True col[j]= True for i in range(n): for j in range(m): if row[i] or col[j]: matrix[i][j]=0","title":"Zero matrix lcci"},{"location":"leetcode/two-pointer/binary-search/binary-search/","text":"# https://leetcode-cn.com/problems/binary-search/ class Solution: def search(self, nums: List[int], target: int) -> int: # eg # nums = [-1,0,3,5,9,12], n = 5 # pivot = 2, val = 3 -> [3...4...5] # pivot = 4, val = 9 i = 0 j = len(nums) -1 while j - i > 1: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot - 1 elif val < target: i = pivot + 1 else: return pivot if nums[i] == target: return i elif nums[j] == target: return j else: return -1","title":"Binary search"},{"location":"leetcode/two-pointer/binary-search/factorial-zeros-lcci/","text":"(leetcode.cc)[https://leetcode-cn.com/problems/factorial-zeros-lcci/submissions/] class Solution: def trailingZeroes(self, n: int) -> int: count = 0 while n>=5: n //=5 count += n return count","title":"Factorial zeros lcci"},{"location":"leetcode/two-pointer/binary-search/first-bad-version/","text":"# https://leetcode-cn.com/problems/first-bad-version/ # The isBadVersion API is already defined for you. # @param version, an integer # @return an integer # def isBadVersion(version): class Solution: def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" i = 1 j = n while j - i > 1: pivot = (j - i) // 2 + i if isBadVersion(pivot): j = pivot else: i = pivot + 1 if isBadVersion(i): return i else: return j","title":"First bad version"},{"location":"leetcode/two-pointer/binary-search/search-insert-position/","text":"class Solution: def searchInsert(self, nums: List[int], target: int) -> int: i = 0 j = len(nums) -1 if nums[i] >= target: return i elif nums[j] < target: return j +1 while j-i >1: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot elif val < target: i = pivot else: return pivot return j","title":"Search insert position"},{"location":"leetcode/two-pointer/slicing-window/longest-substring-without-repeating-characters/","text":"link class Solution: def lengthOfLongestSubstring(self, s: str) -> int: ## sol 1: # ret = 0 # n = len(s) # def isUnique(word): # return len(word) == len(set(list(word))) # for i in range(n): # for j in range(i, n): # guess = s[i:j+1] # if isUnique(guess): # ret = max(ret, len(guess)) # return ret ## sol 2: # acbc # [a]cbc, {a: 0}, i=0,j=0 # [ac]bc, {a:0, c:1}, i=0,j=1 # [acb]c, {a:0, c:1, b:2}, i=0,j=2 # ac[bc], {a:0, c:1, b:2}, c:3, i=1+1=2, j=3 ret = 0 j = 0 i = 0 dic = {} # {char: index} while j < len(s): char = s[j] if char in dic: new_i = dic[char] + 1 if new_i > i: i = new_i dic[char] = j # print(s[i:j+1]) ret = max(ret, j-i+1) j += 1 return ret","title":"Longest substring without repeating characters"},{"location":"leetcode/two-pointer/slicing-window/permutation-in-string/","text":"leetcode.cn class Solution: def checkInclusion(self, s1: str, s2: str) -> bool: # # s1 = \"ab\" # # s2 = \"eidbaooo\" # n = len(s1) # m = len(s2) # dic1 = [] # dic2 = [] # if n>m: return False # for i in range(n): # dic1[i] = s1[i] # for j in range(m): # for j<j+n: # if s2[j] in dic1: # dic2.append(s2[j]) # j += 1 # if len(dic1) == len(dic2): # return True # return False if len(s1) > len(s2): return False m, n = len(s1), len(s2) dic1 = [0]*26 dic2 = [0]*26 # PartI: \u521d\u59cb\u5316\u7edf\u8ba1\u7a97\u53e3\u5b57\u6bcd\u8868 for i in range(m): dic1[ord(s1[i])-ord(\"a\")] += 1 # s1 dic2[ord(s2[i])-ord(\"a\")] += 1 # s2 if dic1 == dic2: return True # PartII: \u6ed1\u52a8\u7a97\u53e3\u5b57\u6bcd\u8868\u66f4\u65b0 for i in range(m,n): dic2[ord(s2[i])-ord(\"a\")] += 1 # \u8fdb dic2[ord(s2[i-m])-ord(\"a\")] -= 1 # \u51fa if dic1 == dic2: return True return False","title":"Permutation in string"},{"location":"leetcode/two-pointer/slicing-window/strStr/","text":"(leetcode.top-interview-questions-easy)[https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnr003/] class Solution: def strStr(self, haystack: str, needle: str) -> int: # # \"hello\" # # i j # # \"ll\" n = len(haystack) m = len(needle) i = 0 if m>n: return -1 while i+m <= n: if haystack[i:i+m] == needle: return i i += 1 return -1","title":"strStr"},{"location":"mkdocs/config/","text":"Config","title":"Config"},{"location":"mkdocs/config/#config","text":"","title":"Config"},{"location":"mkdocs/usage/","text":"Usage","title":"Usage"},{"location":"mkdocs/usage/#usage","text":"","title":"Usage"}]}
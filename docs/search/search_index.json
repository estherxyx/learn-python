{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"estherxyx.github.io/learn-python Intro This is blog about my python study footprint Hello World from estherxyx :","title":"Home"},{"location":"#estherxyxgithubiolearn-python","text":"","title":"estherxyx.github.io/learn-python"},{"location":"#intro","text":"This is blog about my python study footprint Hello World from estherxyx :","title":"Intro"},{"location":"leetcode/data-structure/","text":"Big-O O(1) O(n) : number of elements -> n O(n^2)","title":"Data structure"},{"location":"leetcode/data-structure/#big-o","text":"O(1) O(n) : number of elements -> n O(n^2)","title":"Big-O"},{"location":"leetcode/python-keywrods/","text":"# enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango']","title":"Python keywrods"},{"location":"leetcode/graph/binary-tree-inorder-traversal/","text":"Tree Traversal preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Binary tree inorder traversal"},{"location":"leetcode/graph/binary-tree-inorder-traversal/#tree-traversal","text":"preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Tree Traversal"},{"location":"leetcode/graph/binary-tree-level-order-traversal/","text":"# https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: self.ret = [] def bfs(node): queue = [node] while queue: self.ret.append([n.val for n in queue]) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return self.ret","title":"Binary tree level order traversal"},{"location":"leetcode/graph/number-of-islands/","text":"# https://leetcode-cn.com/problems/number-of-islands/ class Solution: def numIslands(self, grid: List[List[str]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = '-1' ISLAND = '1' count = 0 def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): dfs(nx, ny) def bfs(x, y): grid[x][y] = VISITED queue = [[x, y]] while queue: new_queue = [] for cx, cy in queue: for dx, dy in dirs: nx, ny = cx+dx, cy+dy if isValidPosition(nx, ny): new_queue.append([nx, ny]) grid[nx][ny] = VISITED queue = new_queue for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count += 1 bfs(r, c) return count","title":"Number of islands"},{"location":"leetcode/list-map/two-sum/","text":"# https://leetcode-cn.com/problems/two-sum/ class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: # eg # nums = [2,7,11,15], target = 9 # 2 -> [7,11,15] # 7 -> [11,15] # ... ## sol1: # for i, n in enumerate(nums): # for j, m in enumerate(nums): # if j > i: # if n + m == target: # return [i, j] # return [-1, -1] ## sol2: needed = {} for i, n in enumerate(nums): if n in needed: return [needed[n], i] reminder = target - n needed[reminder] = i return [-1, -1] ## demo # i: 1 # n: 7 # needed: {7: 0} # reminder: 7","title":"Two sum"},{"location":"mkdocs/config/","text":"Config","title":"Config"},{"location":"mkdocs/config/#config","text":"","title":"Config"},{"location":"mkdocs/usage/","text":"Usage","title":"Usage"},{"location":"mkdocs/usage/#usage","text":"","title":"Usage"}]}
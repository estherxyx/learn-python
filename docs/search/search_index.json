{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"estherxyx.github.io/learn-python Intro This is blog about my python study footprint Hello World from estherxyx :","title":"Home"},{"location":"#estherxyxgithubiolearn-python","text":"","title":"estherxyx.github.io/learn-python"},{"location":"#intro","text":"This is blog about my python study footprint Hello World from estherxyx :","title":"Intro"},{"location":"leetcode/data-structure/","text":"WIP leetcode::study-plan::algorithms Big-O O(1) O(n) : number of elements -> n O(n^2) Python Keywords # enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango'] # setting up new array with length n ouside of loops nums = [0]*length # inside the loop no \"append\" or self needed # see eg in squares-of-a-sorted-array","title":"Data structure"},{"location":"leetcode/data-structure/#wip","text":"leetcode::study-plan::algorithms","title":"WIP"},{"location":"leetcode/data-structure/#big-o","text":"O(1) O(n) : number of elements -> n O(n^2)","title":"Big-O"},{"location":"leetcode/data-structure/#python-keywords","text":"# enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango'] # setting up new array with length n ouside of loops nums = [0]*length # inside the loop no \"append\" or self needed # see eg in squares-of-a-sorted-array","title":"Python Keywords"},{"location":"leetcode/binary-search/binary-search/","text":"# https://leetcode-cn.com/problems/binary-search/ class Solution: def search(self, nums: List[int], target: int) -> int: # eg # nums = [-1,0,3,5,9,12], n = 5 # pivot = 2, val = 3 -> [3...4...5] # pivot = 4, val = 9 i = 0 j = len(nums) -1 while j - i > 1: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot - 1 elif val < target: i = pivot + 1 else: return pivot if nums[i] == target: return i elif nums[j] == target: return j else: return -1","title":"Binary search"},{"location":"leetcode/binary-search/first-bad-version/","text":"# https://leetcode-cn.com/problems/first-bad-version/ # The isBadVersion API is already defined for you. # @param version, an integer # @return an integer # def isBadVersion(version): class Solution: def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" i = 1 j = n while j - i > 1: pivot = (j - i) // 2 + i if isBadVersion(pivot): j = pivot else: i = pivot + 1 if isBadVersion(i): return i else: return j","title":"First bad version"},{"location":"leetcode/binary-search/search-insert-position/","text":"class Solution: def searchInsert(self, nums: List[int], target: int) -> int: i = 0 j = len(nums) -1 if nums[i] >= target: return i elif nums[j] < target: return j +1 while j-i >1: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot elif val < target: i = pivot else: return pivot return j","title":"Search insert position"},{"location":"leetcode/binary-tree/binary-tree-inorder-traversal/","text":"Tree Traversal preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Binary tree inorder traversal"},{"location":"leetcode/binary-tree/binary-tree-inorder-traversal/#tree-traversal","text":"preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Tree Traversal"},{"location":"leetcode/binary-tree/binary-tree-level-order-traversal/","text":"# https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: self.ret = [] def bfs(node): queue = [node] while queue: self.ret.append([n.val for n in queue]) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return self.ret","title":"Binary tree level order traversal"},{"location":"leetcode/binary-tree/merge-two-binary-trees/","text":"# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode: def dfs(root1,root2): root = TreeNode() if not root1: return root2 elif not root2: return root1 else: root.val = root1.val + root2.val root.left = dfs(root1.left, root2.left) root.right = dfs(root1.right, root2.right) return root return dfs(root1,root2)","title":"Merge two binary trees"},{"location":"leetcode/dfs/flood-fill-myths/","text":"class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ROW = len(image) COL = len(image[0]) valid_pixel = image[sr][sc] dirs = [[0,1],[1,0],[0,-1],[-1,0]] def isValidPosition(x, y): return x >= 0 and y >=0 and x < ROW and y < COL and image[x][y]== valid_pixel def dfs(x, y): if image[x][y] == valid_pixel: image[x][y] = newColor # for nx,ny in [(x,y+1),(x+1,y),(x,y-1),(x-1,y)]: for dx, dy in dirs: nx,ny = x+dy,y+dy if isValidPosition(nx,ny): dfs(nx,ny) if valid_pixel == newColor: return image else: for r in range(ROW): for c in range(COL): if image[r][c] == valid_pixel: dfs(r, c) return image","title":"Flood fill myths"},{"location":"leetcode/dfs/flood-fill/","text":"class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ROW = len(image) COL = len(image[0]) valid_pixel = image[sr][sc] def isValidPosition(x, y): return x >= 0 and y >=0 and x < ROW and y < COL and image[x][y]== valid_pixel def dfs(x, y): if image[x][y] == valid_pixel: image[x][y] = newColor for nx,ny in [(x,y+1),(x+1,y),(x,y-1),(x-1,y)]: if isValidPosition(nx,ny): dfs(nx,ny) if valid_pixel != newColor: dfs(sr,sc) return image else: return image","title":"Flood fill"},{"location":"leetcode/dfs/max-area-of-island/","text":"class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = -1 area = [] def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED count = 1 for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): count += dfs(nx,ny) return count for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count1 = dfs(r, c) area.append(count1) if not area: return 0 else: return max(area)","title":"Max area of island"},{"location":"leetcode/dfs/number-of-islands/","text":"# https://leetcode-cn.com/problems/number-of-islands/ class Solution: def numIslands(self, grid: List[List[str]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = '-1' ISLAND = '1' count = 0 def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): dfs(nx, ny) def bfs(x, y): grid[x][y] = VISITED queue = [[x, y]] while queue: new_queue = [] for cx, cy in queue: for dx, dy in dirs: nx, ny = cx+dx, cy+dy if isValidPosition(nx, ny): new_queue.append([nx, ny]) grid[nx][ny] = VISITED queue = new_queue for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count += 1 bfs(r, c) return count","title":"Number of islands"},{"location":"leetcode/list-map/two-sum-ii-input-array-is-sorted/","text":"solution #1 copied codes from two-sum solution #2 tried to two pointers method class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: # Solution #1 # copied codes from two-sum # added \"+1\" when return # needed = {} # for i, n in enumerate(numbers): # if n in needed: # return [needed[n]+1, i+1] # reminder = target - n # needed[reminder] = i # return [-1, -1] #Solution #2 two pointers # i from head to tail # j from tail move backwards i = 0 j = len(numbers)-1 while j>i: val = numbers[j] + numbers[i] if val == target: return[i+1,j+1] elif val > target: j -= 1 else: i += 1 return [-1, -1]","title":"Two sum ii input array is sorted"},{"location":"leetcode/list-map/two-sum/","text":"# https://leetcode-cn.com/problems/two-sum/ class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: # eg # nums = [2,7,11,15], target = 9 # 2 -> [7,11,15] # 7 -> [11,15] # ... ## sol1: # for i, n in enumerate(nums): # for j, m in enumerate(nums): # if j > i: # if n + m == target: # return [i, j] # return [-1, -1] ## sol2: needed = {} for i, n in enumerate(nums): if n in needed: return [needed[n], i] reminder = target - n needed[reminder] = i return [-1, -1] ## demo # i: 1 # n: 7 # needed: {7: 0} # reminder: 7","title":"Two sum"},{"location":"leetcode/two-pointer/move-zeroes/","text":"class Solution: def moveZeroes(self, nums: List[int]) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" i = 0 j = 0 while i<len(nums): if nums[i] !=0: nums[j],nums[i] = nums[i],nums[j] j += 1 i += 1","title":"Move zeroes"},{"location":"leetcode/two-pointer/remove-duplicates-from-sorted-array/","text":"# https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ class Solution: def removeDuplicates(self, nums: List[int]) -> int: # eg # nums = [0,1,2,3,4,2,2,3,3,4] # nums = [0,1,2,3,1,2,2,3,3,4] # i # j i = 0 j = 0 while j < len(nums): if nums[i] == nums[j]: j += 1 else: i += 1 nums[i] = nums[j] return i + 1","title":"Remove duplicates from sorted array"},{"location":"leetcode/two-pointer/reverse-string/","text":"reverse string as in list class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" i = 0 j = len(s)-1 while j>i: s[j], s[i] = s[i] + s[j] j -= 1 i += 1 reverse string as string \"\" split(\"\") to split \" I love pizza\" as per word list: [\"I\",\"love\",\"pizza\"] split(\"\")[::-1] to reverse each word in list [\"I\",\"evol\",\"azzip\"] .join(split(\"\")[::-1]) to make it as string and .join(split(\"\")[::-1])[::-1] to reverse the whole thing class Solution: def reverseWords(self, s: str) -> str: return \" \".join(s.split(\" \")[::-1])[::-1]","title":"Reverse string"},{"location":"leetcode/two-pointer/reverse-string/#reverse-string-as-in-list","text":"class Solution: def reverseString(self, s: List[str]) -> None: \"\"\" Do not return anything, modify s in-place instead. \"\"\" i = 0 j = len(s)-1 while j>i: s[j], s[i] = s[i] + s[j] j -= 1 i += 1","title":"reverse string as in list"},{"location":"leetcode/two-pointer/reverse-string/#reverse-string-as-string","text":"split(\"\") to split \" I love pizza\" as per word list: [\"I\",\"love\",\"pizza\"] split(\"\")[::-1] to reverse each word in list [\"I\",\"evol\",\"azzip\"] .join(split(\"\")[::-1]) to make it as string and .join(split(\"\")[::-1])[::-1] to reverse the whole thing class Solution: def reverseWords(self, s: str) -> str: return \" \".join(s.split(\" \")[::-1])[::-1]","title":"reverse string as string \"\""},{"location":"leetcode/two-pointer/rotate-array/","text":"did not use two pointer method lol the array was slides and added afterwards class Solution: def rotate(self, nums: List[int], k: int) -> None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) if k > 0: reminder = n - k % n nums[:] = nums[reminder:] + nums[:reminder] else: nums[:] = nums[:]","title":"Rotate array"},{"location":"leetcode/two-pointer/squares-of-a-sorted-array/","text":"class Solution: def sortedSquares(self, nums: List[int]) -> List[int]: i = 0 j = len(nums)-1 k = len(nums)-1 nums_squared = [0]*len(nums) while i<= j: if nums[i] *nums[i] > nums[j] * nums[j]: nums_squared[k] = nums[i] *nums[i] i += 1 else: nums_squared[k] = nums[j] *nums[j] j -= 1 k -=1 return nums_squared","title":"Squares of a sorted array"},{"location":"mkdocs/config/","text":"Config","title":"Config"},{"location":"mkdocs/config/#config","text":"","title":"Config"},{"location":"mkdocs/usage/","text":"Usage","title":"Usage"},{"location":"mkdocs/usage/#usage","text":"","title":"Usage"}]}
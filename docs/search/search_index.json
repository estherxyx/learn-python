{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"estherxyx.github.io/learn-python Intro This is blog about my python study footprint Hello World from estherxyx :","title":"Home"},{"location":"#estherxyxgithubiolearn-python","text":"","title":"estherxyx.github.io/learn-python"},{"location":"#intro","text":"This is blog about my python study footprint Hello World from estherxyx :","title":"Intro"},{"location":"leetcode/data-structure/","text":"WIP https://leetcode-cn.com/study-plan/algorithms/?progress=2t9i8es Big-O O(1) O(n) : number of elements -> n O(n^2) Python Keywords # enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango']","title":"Data structure"},{"location":"leetcode/data-structure/#wip","text":"https://leetcode-cn.com/study-plan/algorithms/?progress=2t9i8es","title":"WIP"},{"location":"leetcode/data-structure/#big-o","text":"O(1) O(n) : number of elements -> n O(n^2)","title":"Big-O"},{"location":"leetcode/data-structure/#python-keywords","text":"# enumerate for i, n in enumerate([10,20,30]): print(i, n) # >>> 0, 10 # >>> 1, 20 # >>> 2, 30 # slice [1,2,3][1:] # [2,3] # map m = {} m1 = { 1 : 'Yi'} m[1] = 'one' if lang == 'english': print(m[1]) else: print(m1[1]) # List Comprehension fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"] newlist = [x for x in fruits if \"a\" in x] # >>> ['apple', 'banana', 'mango']","title":"Python Keywords"},{"location":"leetcode/binary-search/binary-search/","text":"# https://leetcode-cn.com/problems/binary-search/ class Solution: def search(self, nums: List[int], target: int) -> int: # eg # nums = [-1,0,3,5,9,12], n = 5 # pivot = 2, val = 3 -> [3...4...5] # pivot = 4, val = 9 i = 0 j = len(nums) -1 while i <= j: pivot = (j - i) // 2 + i val = nums[pivot] if val > target: j = pivot - 1 elif val < target: i = pivot + 1 else: return pivot return -1","title":"Binary search"},{"location":"leetcode/graph/binary-tree-inorder-traversal/","text":"Tree Traversal preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Binary tree inorder traversal"},{"location":"leetcode/graph/binary-tree-inorder-traversal/#tree-traversal","text":"preorder: mid left right inorder: left mid right postorder: left right mid # https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # inorder: left mid right ret = [] if root: ret += self.inorderTraversal(root.left) ret.append(root.val) ret += self.inorderTraversal(root.right) return ret","title":"Tree Traversal"},{"location":"leetcode/graph/binary-tree-level-order-traversal/","text":"# https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: self.ret = [] def bfs(node): queue = [node] while queue: self.ret.append([n.val for n in queue]) new_queue = [] for cur_node in queue: for tmp_node in [cur_node.left, cur_node.right]: if tmp_node: new_queue.append(tmp_node) queue = new_queue if root: bfs(root) return self.ret","title":"Binary tree level order traversal"},{"location":"leetcode/graph/number-of-islands/","text":"# https://leetcode-cn.com/problems/number-of-islands/ class Solution: def numIslands(self, grid: List[List[str]]) -> int: dirs = [[0,1],[1,0],[0,-1],[-1,0]] ROW = len(grid) COL = len(grid[0]) VISITED = '-1' ISLAND = '1' count = 0 def isValidPosition(x, y): return x >= 0 and y >= 0 and x < ROW and y < COL and grid[x][y] == ISLAND def dfs(x, y): grid[x][y] = VISITED for dx, dy in dirs: nx, ny = x+dx, y+dy if isValidPosition(nx, ny): dfs(nx, ny) def bfs(x, y): grid[x][y] = VISITED queue = [[x, y]] while queue: new_queue = [] for cx, cy in queue: for dx, dy in dirs: nx, ny = cx+dx, cy+dy if isValidPosition(nx, ny): new_queue.append([nx, ny]) grid[nx][ny] = VISITED queue = new_queue for r in range(ROW): for c in range(COL): if grid[r][c] == ISLAND: count += 1 bfs(r, c) return count","title":"Number of islands"},{"location":"leetcode/list-map/two-sum/","text":"# https://leetcode-cn.com/problems/two-sum/ class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: # eg # nums = [2,7,11,15], target = 9 # 2 -> [7,11,15] # 7 -> [11,15] # ... ## sol1: # for i, n in enumerate(nums): # for j, m in enumerate(nums): # if j > i: # if n + m == target: # return [i, j] # return [-1, -1] ## sol2: needed = {} for i, n in enumerate(nums): if n in needed: return [needed[n], i] reminder = target - n needed[reminder] = i return [-1, -1] ## demo # i: 1 # n: 7 # needed: {7: 0} # reminder: 7","title":"Two sum"},{"location":"leetcode/two-pointer/remove-duplicates-from-sorted-array/","text":"# https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ class Solution: def removeDuplicates(self, nums: List[int]) -> int: # eg # nums = [0,1,2,3,4,2,2,3,3,4] # nums = [0,1,2,3,1,2,2,3,3,4] # i # j i = 0 j = 0 while j < len(nums): if nums[i] == nums[j]: j += 1 else: i += 1 nums[i] = nums[j] return i + 1","title":"Remove duplicates from sorted array"},{"location":"mkdocs/config/","text":"Config","title":"Config"},{"location":"mkdocs/config/#config","text":"","title":"Config"},{"location":"mkdocs/usage/","text":"Usage","title":"Usage"},{"location":"mkdocs/usage/#usage","text":"","title":"Usage"}]}